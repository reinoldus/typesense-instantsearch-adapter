{"version":3,"sources":["../src/SearchRequestAdapter.js"],"names":["SearchRequestAdapter","instantsearchRequests","typesenseClient","additionalSearchParameters","collectionSpecificSearchParameters","facetFilters","adaptedResult","parseFacetFilter","facetFilter","facetFilterMatches","match","constructor","FILER_STRING_MATCHING_REGEX","console","log","fieldName","groups","fieldValue","negative","replace","String","transformedTypesenseFilters","map","item","Array","isArray","intermediateFacetFilters","intermediateNegativeFacetFilters","forEach","push","Object","keys","length","error","join","typesenseFilterString","fieldValues","numericFilters","filtersHash","filter","RegExp","field","operator","value","adaptedFilters","warn","JSON","stringify","_adaptFacetFilters","_adaptNumericFilters","indexName","INDEX_NAME_MATCHING_REGEX","instantsearchRequest","params","adaptedCollectionName","_adaptIndexName","snakeCasedAdditionalSearchParameters","entries","key","_camelToSnakeCase","typesenseSearchParams","assign","adaptedSortBy","_adaptSortBy","collection","q","query","undefined","facet_by","facets","flat","filter_by","_adaptFilters","sort_by","sortBy","max_facet_values","maxValuesPerFacet","page","hitsPerPage","per_page","facetQuery","facet_query","facetName","str","split","toLowerCase","searches","_buildSearchParameters","multiSearch","perform"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexport class SearchRequestAdapter {\n  static get INDEX_NAME_MATCHING_REGEX() {\n    return new RegExp(\"^(.+?)(?=(/sort/(.*))|$)\");\n  }\n\n  static get FILER_STRING_MATCHING_REGEX() {\n    // I called group2, not sure because I am not sure why it is there\n    return new RegExp(\"(?<fieldName>.*)(?<notSure>(?!:).):(?<negative>-)?(?!:)(?<value>.*)\");\n  }\n\n  constructor(instantsearchRequests, typesenseClient, additionalSearchParameters, collectionSpecificSearchParameters) {\n    this.instantsearchRequests = instantsearchRequests;\n    this.typesenseClient = typesenseClient;\n    this.additionalSearchParameters = additionalSearchParameters;\n    this.collectionSpecificSearchParameters = collectionSpecificSearchParameters;\n  }\n\n  _adaptFacetFilters(facetFilters) {\n    let adaptedResult = \"\";\n\n    if (!facetFilters) {\n      return adaptedResult;\n    }\n\n    /**\n     * Need to transform:\n     *  facetFilters = [[\"field1:value1\", \"field1:value2\"], \"field2:value3\", \"field2:value4\"]\n     *\n     * Into this:\n     *  field1:=[value1,value2] && field2:=value3 && field2:=value4\n     *\n     * Steps:\n     *  - For each item in facetFilters\n     *    - If item is array\n     *      - OR values together.\n     *      - Warn if field names are not the same\n     *    - If item is string, convert to facet:=value format\n     *  - Join strings by &&\n     */\n\n    const parseFacetFilter = (facetFilter) => {\n      const facetFilterMatches = facetFilter.match(this.constructor.FILER_STRING_MATCHING_REGEX);\n      console.log(facetFilterMatches)\n      const fieldName = `${facetFilterMatches.groups[\"fieldName\"]}${facetFilterMatches.groups[\"notSure\"]}`;\n      let fieldValue = `${facetFilterMatches.groups[\"value\"]}`;\n      let negative = false;\n\n      // Check if is negative facet: https://www.algolia.com/doc/api-reference/api-parameters/facetFilters/\n      // This is an insanely simple approach\n      if (facetFilterMatches.groups.negative) {\n        negative = true;\n      } else {\n        // replace \\- with - so a facetValue can start with \"-\" assuming it was escaped before hand\n        // untested\n        fieldValue.replace(\"\\\\-\", \"-\");\n      }\n\n      // Escape all facets except booleans\n      if (!(String(fieldValue) === \"true\" || String(fieldValue) === \"false\")) {\n        fieldValue = \"`\" + fieldValue + \"`\";\n      }\n\n      return { fieldName, fieldValue, negative };\n    };\n\n    const transformedTypesenseFilters = facetFilters.map((item) => {\n      // console.log(item);\n      if (Array.isArray(item)) {\n        // Need to transform:\n        // facetFilters = [\"field1:value1\", \"field1:value2\", \"facetN:valueN\"]\n        //\n        // Into this:\n        // intermediateFacetFilters = {\n        //     \"field1\": [\"value1\", \"value2\"],\n        //     \"fieldN\": [\"valueN\"]\n        // }\n\n        const intermediateFacetFilters = {};\n        const intermediateNegativeFacetFilters = {};\n\n        item.forEach((facetFilter) => {\n          const { fieldName, fieldValue, negative } = parseFacetFilter(facetFilter);\n\n          // console.log(fieldName, fieldValue, negative);\n          if (negative) {\n            intermediateNegativeFacetFilters[fieldName] = intermediateNegativeFacetFilters[fieldName] || [];\n            intermediateNegativeFacetFilters[fieldName].push(fieldValue);\n          } else {\n            intermediateFacetFilters[fieldName] = intermediateFacetFilters[fieldName] || [];\n            intermediateFacetFilters[fieldName].push(fieldValue);\n          }\n        });\n\n        // console.log(\"intermediateFacetFilters\", intermediateFacetFilters);\n\n        if (Object.keys(intermediateFacetFilters).length > 1) {\n          console.error(\n            `Typesense does not support cross-field ORs at the moment. The adapter could not OR values between these fields: ${Object.keys(\n              intermediateFacetFilters\n            ).join(\",\")}`\n          );\n        } else if (Object.keys(intermediateNegativeFacetFilters).length > 1) {\n          console.error(\n            `Typesense does not support cross-field ORs at the moment. The adapter could not OR values between these fields: ${Object.keys(\n              intermediateNegativeFacetFilters\n            ).join(\",\")}`\n          );\n        }\n\n        // Need to transform:\n        // intermediateFacetFilters = {\n        //     \"field1\": [\"value1\", \"value2\"],\n        // }\n        //\n        // Into this:\n        // field1:=[value1,value2]\n\n        const typesenseFilterString = [];\n        if (Object.keys(intermediateFacetFilters).length > 0) {\n          // Pick first value from intermediateFacetFilters\n          // const fieldName = Object.keys(intermediateFacetFilters)[0];\n          // const fieldValues = intermediateFacetFilters[fieldName];\n          const fieldName = Object.keys(intermediateFacetFilters)[0];\n          const fieldValues = intermediateFacetFilters[fieldName];\n          typesenseFilterString.push(`${fieldName}:=[${fieldValues.join(\",\")}]`);\n          // console.log(fieldName, fieldValues, typesenseFilterString);\n        }\n\n        if (Object.keys(intermediateNegativeFacetFilters).length > 0) {\n          const fieldName = Object.keys(intermediateNegativeFacetFilters)[0];\n          const fieldValues = intermediateNegativeFacetFilters[fieldName];\n          // typesenseNegativeFilterString = `${fieldName}:-[${fieldValues.join(\",\")}]`;\n          typesenseFilterString.push(`${fieldName}:-[${fieldValues.join(\",\")}]`);\n        }\n\n        return typesenseFilterString.join(\" && \");\n      } else {\n        // Need to transform:\n        //  fieldName:fieldValue\n        // Into\n        //  fieldName:=fieldValue\n\n        const { fieldName, fieldValue, negative } = parseFacetFilter(item);\n        let typesenseFilterString;\n        if (negative) {\n          typesenseFilterString = `${fieldName}:- [${fieldValue}]`;\n        } else {\n          typesenseFilterString = `${fieldName}:=[${fieldValue}]`;\n        }\n        // console.log(fieldName, fieldValue, negative);\n        // console.log(typesenseFilterString);\n\n        return typesenseFilterString;\n      }\n    });\n\n    adaptedResult = transformedTypesenseFilters.join(\" && \");\n    // console.log(`${JSON.stringify(facetFilters)} => ${adaptedResult}`);\n\n    return adaptedResult;\n  }\n\n  _adaptNumericFilters(numericFilters) {\n    // Need to transform this:\n    // [\"field1<=634\", \"field1>=289\", \"field2<=5\", \"field3>=3\"]\n    // to:\n    // \"field1:=[634..289] && field2:<=5 && field3:>=3\"\n    let adaptedResult = \"\";\n\n    if (!numericFilters) {\n      return adaptedResult;\n    }\n\n    // Transform to intermediate structure:\n    // {\n    //   field1: {\n    //     \"<=\": 634,\n    //     \">=\": 289\n    //   },\n    //   field2: {\n    //     \"<=\": 5\n    //   },\n    //   field3: {\n    //     \">=\": 3\n    //   }\n    // };\n    const filtersHash = {};\n    numericFilters.forEach((filter) => {\n      const [, field, operator, value] = filter.match(new RegExp(\"(.*)(<=|>=|>|<|:)(.*)\"));\n      filtersHash[field] = filtersHash[field] || {};\n      filtersHash[field][operator] = value;\n    });\n\n    // Transform that to:\n    //  \"field1:=[634..289] && field2:<=5 && field3:>=3\"\n    const adaptedFilters = [];\n    Object.keys(filtersHash).forEach((field) => {\n      if (filtersHash[field][\"<=\"] != null && filtersHash[field][\">=\"] != null) {\n        adaptedFilters.push(`${field}:=[${filtersHash[field][\">=\"]}..${filtersHash[field][\"<=\"]}]`);\n      } else if (filtersHash[field][\"<=\"] != null) {\n        adaptedFilters.push(`${field}:<=${filtersHash[field][\"<=\"]}`);\n      } else if (filtersHash[field][\">=\"] != null) {\n        adaptedFilters.push(`${field}:>=${filtersHash[field][\">=\"]}`);\n      } else {\n        console.warn(`Unsupported operator found ${JSON.stringify(filtersHash[field])}`);\n      }\n    });\n\n    adaptedResult = adaptedFilters.join(\" && \");\n    return adaptedResult;\n  }\n\n  _adaptFilters(facetFilters, numericFilters) {\n    const adaptedFilters = [];\n\n    adaptedFilters.push(this._adaptFacetFilters(facetFilters));\n    adaptedFilters.push(this._adaptNumericFilters(numericFilters));\n\n    return adaptedFilters.filter((filter) => filter !== \"\").join(\" && \");\n  }\n\n  _adaptIndexName(indexName) {\n    return indexName.match(this.constructor.INDEX_NAME_MATCHING_REGEX)[1];\n  }\n\n  _adaptSortBy(indexName) {\n    return indexName.match(this.constructor.INDEX_NAME_MATCHING_REGEX)[3];\n  }\n\n  _buildSearchParameters(instantsearchRequest) {\n    const params = instantsearchRequest.params;\n    const indexName = instantsearchRequest.indexName;\n    const adaptedCollectionName = this._adaptIndexName(indexName);\n\n    // Convert all common parameters to snake case\n    const snakeCasedAdditionalSearchParameters = {};\n    for (const [key, value] of Object.entries(this.additionalSearchParameters)) {\n      snakeCasedAdditionalSearchParameters[this._camelToSnakeCase(key)] = value;\n    }\n\n    // Override, collection specific parameters\n    if (this.collectionSpecificSearchParameters[adaptedCollectionName]) {\n      for (const [key, value] of Object.entries(this.collectionSpecificSearchParameters[adaptedCollectionName])) {\n        snakeCasedAdditionalSearchParameters[this._camelToSnakeCase(key)] = value;\n      }\n    }\n\n    const typesenseSearchParams = Object.assign({}, snakeCasedAdditionalSearchParameters);\n\n    const adaptedSortBy = this._adaptSortBy(indexName);\n    // console.log(params);\n\n    Object.assign(typesenseSearchParams, {\n      collection: adaptedCollectionName,\n      q: params.query === \"\" || params.query === undefined ? \"*\" : params.query,\n      facet_by: [params.facets].flat().join(\",\"),\n      filter_by: this._adaptFilters(params.facetFilters, params.numericFilters),\n      sort_by: adaptedSortBy || this.additionalSearchParameters.sortBy,\n      max_facet_values: params.maxValuesPerFacet,\n      page: (params.page || 0) + 1,\n    });\n\n    if (params.hitsPerPage) {\n      typesenseSearchParams.per_page = params.hitsPerPage;\n    }\n\n    if (params.facetQuery) {\n      typesenseSearchParams.facet_query = `${params.facetName}:${params.facetQuery}`;\n      typesenseSearchParams.per_page = 0;\n    }\n\n    // console.log(params);\n    // console.log(typesenseSearchParams);\n\n    return typesenseSearchParams;\n  }\n\n  _camelToSnakeCase(str) {\n    return str\n      .split(/(?=[A-Z])/)\n      .join(\"_\")\n      .toLowerCase();\n  }\n\n  async request() {\n    const searches = this.instantsearchRequests.map((instantsearchRequest) =>\n      this._buildSearchParameters(instantsearchRequest)\n    );\n\n    return this.typesenseClient.multiSearch.perform({ searches: searches });\n  }\n}\n"],"file":"SearchRequestAdapter.js"}